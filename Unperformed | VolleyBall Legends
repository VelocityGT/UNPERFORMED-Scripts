-- File: unperformed_volleyball_legends.lua
-- UNPERFORMED | Volleyball Legends â€” Full GUI + Auto Hit (Hitbox Expander + 3D Sphere)

----------------------------------------------------------------
-- Rayfield UI
----------------------------------------------------------------
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
    Name = "UNPERFORMED | Volleyball Legends",
    Icon = "cloud-lightning",
    LoadingTitle = "Unperformed Services Official",
    LoadingSubtitle = "by UNPERFORMED",
    ShowText = "UNPERFORMED",
    Theme = "Default",
    ToggleUIKeybind = "K",
    DisableRayfieldPrompts = false,
    DisableBuildWarnings = false,
    ConfigurationSaving = { Enabled = true, FolderName = nil, FileName = "Big Hub" },
    Discord = { Enabled = false, Invite = "noinvitelink", RememberJoins = true },
    KeySystem = false,
    KeySettings = { Title = "Untitled", Subtitle = "Key System", Note = "No method of obtaining the key is provided", FileName = "Key", SaveKey = true, GrabKeyFromSite = false, Key = {"Hello"} }
})

-- Tabs
local PlayerTab  = Window:CreateTab("Player", "user")
local VisualTab  = Window:CreateTab("Visual", "eye")
local BlatantTab = Window:CreateTab("Blatant", "skull")
local InfoTab    = Window:CreateTab("Info", "album")

----------------------------------------------------------------
-- Services / Refs
----------------------------------------------------------------
local Players      = game:GetService("Players")
local RunService   = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UIS          = game:GetService("UserInputService")
local VIM          = game:GetService("VirtualInputManager")

local lp = Players.LocalPlayer
local camera = workspace.CurrentCamera

local character = lp.Character or lp.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

lp.CharacterAdded:Connect(function(char)
    character = char
    hrp = char:WaitForChild("HumanoidRootPart")
end)

----------------------------------------------------------------
-- Player: WalkSpeed / JumpPower
----------------------------------------------------------------
PlayerTab:CreateDivider()

local walkspeedEnabled = false
local jumppowerEnabled = false

local function getHumanoid(playerObj)
    local char = playerObj.Character or playerObj.CharacterAdded:Wait()
    return char:FindFirstChildWhichIsA("Humanoid")
end

local WalkToggle
local SpeedSlider

WalkToggle = PlayerTab:CreateToggle({
    Name = "WalkSpeed Enabled",
    CurrentValue = false,
    Flag = "WalkToggle1",
    Callback = function(Value)
        walkspeedEnabled = Value
        local hum = getHumanoid(lp)
        if not hum then return end
        hum.WalkSpeed = walkspeedEnabled and SpeedSlider.CurrentValue or 16
    end,
})

SpeedSlider = PlayerTab:CreateSlider({
    Name = "WalkSpeed Value",
    Range = {16, 100},
    Increment = 1,
    Suffix = "Speed",
    CurrentValue = 16,
    Flag = "SpeedSlider1",
    Callback = function(Value)
        if not walkspeedEnabled then return end
        local hum = getHumanoid(lp)
        if hum then hum.WalkSpeed = Value end
    end,
})

task.spawn(function()
    while true do
        task.wait(0.1)
        if walkspeedEnabled then
            local hum = getHumanoid(lp)
            if hum then hum.WalkSpeed = SpeedSlider.CurrentValue end
        end
    end
end)

PlayerTab:CreateDivider()

local JumpSlider
PlayerTab:CreateToggle({
    Name = "JumpPower Enabled",
    CurrentValue = false,
    Flag = "JumpToggle1",
    Callback = function(Value)
        jumppowerEnabled = Value
        local hum = getHumanoid(lp)
        if not hum then return end
        hum.JumpPower = jumppowerEnabled and JumpSlider.CurrentValue or 50
    end,
})

JumpSlider = PlayerTab:CreateSlider({
    Name = "JumpPower",
    Range = {0, 200},
    Increment = 1,
    Suffix = "Power",
    CurrentValue = 50,
    Flag = "JumpSlider1",
    Callback = function(Value)
        if not jumppowerEnabled then return end
        local hum = getHumanoid(lp)
        if hum then hum.JumpPower = Value end
    end,
})

task.spawn(function()
    while true do
        task.wait(0.1)
        if jumppowerEnabled then
            local hum = getHumanoid(lp)
            if hum then hum.JumpPower = JumpSlider.CurrentValue end
        end
    end
end)

PlayerTab:CreateDivider()

----------------------------------------------------------------
-- Noclip
----------------------------------------------------------------
local noclipEnabled = false

PlayerTab:CreateToggle({
    Name = "Noclip",
    CurrentValue = false,
    Flag = "NoclipToggle1",
    Callback = function(Value)
        noclipEnabled = Value
    end,
})

RunService.Stepped:Connect(function()
    if not noclipEnabled or not character then return end
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = false
        end
    end
end)

----------------------------------------------------------------
-- Fly
----------------------------------------------------------------
character = lp.Character or lp.CharacterAdded:Wait()
hrp = character:WaitForChild("HumanoidRootPart")

local flying = false
local flySpeed = 50

local vel = Instance.new("BodyVelocity")
vel.MaxForce = Vector3.new(9e9, 9e9, 9e9)
vel.P = 12500

PlayerTab:CreateToggle({
    Name = "Fly",
    CurrentValue = false,
    Flag = "FlyToggle",
    Callback = function(Value)
        flying = Value
        vel.Parent = flying and hrp or nil
    end,
})

PlayerTab:CreateSlider({
    Name = "Fly Speed",
    Range = {10, 150},
    Increment = 1,
    Suffix = "Speed",
    CurrentValue = 50,
    Flag = "FlySpeed",
    Callback = function(Value) flySpeed = Value end,
})

lp.CharacterAdded:Connect(function(char)
    character = char
    hrp = char:WaitForChild("HumanoidRootPart")
    if flying then vel.Parent = hrp end
end)

RunService.Heartbeat:Connect(function()
    if not flying then return end
    local cam = workspace.CurrentCamera
    local moveDir = Vector3.new()

    if UIS:IsKeyDown(Enum.KeyCode.W) then moveDir += cam.CFrame.LookVector end
    if UIS:IsKeyDown(Enum.KeyCode.S) then moveDir -= cam.CFrame.LookVector end
    if UIS:IsKeyDown(Enum.KeyCode.A) then moveDir -= cam.CFrame.RightVector end
    if UIS:IsKeyDown(Enum.KeyCode.D) then moveDir += cam.CFrame.RightVector end
    if UIS:IsKeyDown(Enum.KeyCode.E) then moveDir += Vector3.new(0,1,0) end
    if UIS:IsKeyDown(Enum.KeyCode.Q) then moveDir -= Vector3.new(0,1,0) end

    if moveDir.Magnitude > 0 then moveDir = moveDir.Unit end
    vel.Velocity = moveDir * flySpeed
end)

----------------------------------------------------------------
-- Visual: Chams ESP
----------------------------------------------------------------
VisualTab:CreateDivider()

local espEnabled = false
local espColor = Color3.fromRGB(0, 255, 255)
local highlights = {}

local function attachHighlight(char)
    local h = Instance.new("Highlight")
    h.FillColor = espColor
    h.OutlineColor = Color3.new(1,1,1)
    h.FillTransparency = 0.25
    h.OutlineTransparency = 0
    h.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    h.Parent = char
    return h
end

local function applyESP(p)
    if p == lp then return end
    if p.Character and espEnabled then
        highlights[p] = attachHighlight(p.Character)
    end
    p.CharacterAdded:Connect(function(char)
        if not espEnabled then return end
        task.wait(0.1)
        highlights[p] = attachHighlight(char)
    end)
end

local function clearESP()
    for _, h in pairs(highlights) do
        if h then h:Destroy() end
    end
    highlights = {}
end

VisualTab:CreateToggle({
    Name = "Chams ESP",
    CurrentValue = false,
    Flag = "ChamsESP",
    Callback = function(Value)
        espEnabled = Value
        if espEnabled then
            for _, p in pairs(Players:GetPlayers()) do
                if p ~= lp then
                    if p.Character then
                        highlights[p] = attachHighlight(p.Character)
                    end
                    applyESP(p)
                end
            end
        else
            clearESP()
        end
    end,
})

VisualTab:CreateColorPicker({
    Name = "ESP Color",
    Color = espColor,
    Flag = "ChamsESPColor",
    Callback = function(color)
        espColor = color
        for _, h in pairs(highlights) do
            if h then h.FillColor = espColor end
        end
    end,
})

Players.PlayerAdded:Connect(applyESP)
Players.PlayerRemoving:Connect(function(p)
    local h = highlights[p]
    if h then h:Destroy() end
    highlights[p] = nil
end)

----------------------------------------------------------------
-- Visual: TRACERS (fixed position handling)
----------------------------------------------------------------
VisualTab:CreateDivider()

local tracersEnabled = false
local tracerColor = Color3.fromRGB(255, 0, 0)
local tracerPosition = "Bottom"
local tracers = {}

local function createTracer(p)
    if p == lp then return end
    local line = Drawing.new("Line")
    line.Thickness = 2
    line.Color = tracerColor
    line.Visible = tracersEnabled
    tracers[p] = line
end

local function destroyTracer(p)
    local t = tracers[p]
    if t then t:Remove() end
    tracers[p] = nil
end

local function getStartPos()
    local v = camera.ViewportSize
    if tracerPosition == "Center" then
        return Vector2.new(v.X * 0.5, v.Y * 0.5)
    elseif tracerPosition == "Top" then
        return Vector2.new(v.X * 0.5, 10)
    else
        return Vector2.new(v.X * 0.5, v.Y - 10)
    end
end

RunService.RenderStepped:Connect(function()
    local start = getStartPos()

    if not tracersEnabled then
        for _, t in pairs(tracers) do
            if t then t.Visible = false end
        end
        return
    end

    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= lp then
            local line = tracers[p]
            if not line then
                createTracer(p)
                line = tracers[p]
            end

            local char2 = p.Character
            local hrpOther = char2 and char2:FindFirstChild("HumanoidRootPart")

            if line and hrpOther then
                local pos, onScreen = camera:WorldToViewportPoint(hrpOther.Position)
                if onScreen then
                    line.Visible = true
                    line.Color = tracerColor
                    line.From = start
                    line.To = Vector2.new(pos.X, pos.Y)
                else
                    line.Visible = false
                end
            elseif line then
                line.Visible = false
            end
        end
    end
end)

Players.PlayerAdded:Connect(createTracer)
Players.PlayerRemoving:Connect(destroyTracer)
for _, p in ipairs(Players:GetPlayers()) do createTracer(p) end

VisualTab:CreateToggle({
    Name = "Tracers",
    CurrentValue = false,
    Flag = "TracersToggle",
    Callback = function(v)
        tracersEnabled = v
        for _, t in pairs(tracers) do
            if t then t.Visible = v end
        end
    end,
})

VisualTab:CreateColorPicker({
    Name = "Tracer Color",
    Color = tracerColor,
    Flag = "TracerColor",
    Callback = function(c)
        tracerColor = c
        for _, t in pairs(tracers) do
            if t and t.Visible then t.Color = c end
        end
    end,
})

VisualTab:CreateDropdown({
    Name = "Tracer Position",
    Options = {"Center","Bottom","Top"},
    CurrentOption = "Bottom",
    Flag = "TracerPosition",
    Callback = function(o)
        if typeof(o) == "table" then tracerPosition = o[1] else tracerPosition = o end
    end,
})

----------------------------------------------------------------
-- Blatant: AUTO HIT (Hitbox Expander + 3D Radius Sphere)
----------------------------------------------------------------
BlatantTab:CreateDivider()

-- Helpers (ball + GUI)
local function safeGetBasePartFromModel(model)
    if model.PrimaryPart then return model.PrimaryPart end
    for _, d in ipairs(model:GetDescendants()) do
        if d:IsA("BasePart") then return d end
    end
    return nil
end

local function findClientBall()
    for _, inst in ipairs(workspace:GetChildren()) do
        local name = inst.Name or ""
        if string.sub(name, 1, 12) == "CLIENT_BALL_" then
            if inst:IsA("BasePart") then
                return inst
            elseif inst:IsA("Model") then
                local part = safeGetBasePartFromModel(inst)
                if part then return part end
            end
        end
    end
    return nil
end

local function getBumpButton()
    local pg = lp:FindFirstChild("PlayerGui")
    if not pg then return nil end

    local ok, btn = pcall(function()
        return pg
            :WaitForChild("Interface", 0.1)
            :WaitForChild("Game", 0.1)
            :WaitForChild("InGameActionsBar", 0.1)
            :WaitForChild("Mobile", 0.1)
            :WaitForChild("Actions", 0.1)
            :WaitForChild("Bump", 0.1)
    end)
    if ok and btn and btn:IsA("GuiButton") then return btn end

    for _, d in ipairs(pg:GetDescendants()) do
        if d.Name == "Bump" and d:IsA("GuiButton") and d.Parent and d.Parent.Name == "Actions" then
            return d
        end
    end
    return nil
end

local function pressBump(btn)
    if not btn then return end
    pcall(function() btn:Activate() end) -- why: some UIs only listen to Activate
    local ok, pos, size = pcall(function()
        return btn.AbsolutePosition, btn.AbsoluteSize
    end)
    if ok and pos and size then
        local center = pos + (size / 2)
        pcall(function()
            VIM:SendMouseButtonEvent(center.X, center.Y, 0, true, btn, 0)
            VIM:SendMouseButtonEvent(center.X, center.Y, 0, false, btn, 0)
        end)
    end
end

-- Config
local expandEnabled     = false
local hitRadius         = 18
local clickCooldown     = 0.25

local showRadiusSphere  = true
local sphereTransparency= 0.75
local sphereColor       = Color3.fromRGB(90,170,255)

-- Welded invisible bubble (client reach)
local function weldTo(part, toPart)
    local w = Instance.new("WeldConstraint")
    w.Part0 = toPart
    w.Part1 = part
    w.Parent = part
    return w
end

local function ensureHitBubble()
    if not hrp then return end
    local bubble = hrp:FindFirstChild("__HitBubble")
    local sizeVec = Vector3.new(hitRadius*2, hitRadius*2, hitRadius*2)

    if not bubble then
        bubble = Instance.new("Part")
        bubble.Name = "__HitBubble"
        bubble.Shape = Enum.PartType.Ball
        bubble.Material = Enum.Material.ForceField
        bubble.CanCollide = false
        bubble.CanQuery = false
        bubble.CanTouch = false -- why: detection by distance, not Touched
        bubble.Massless = true
        bubble.CastShadow = false
        bubble.Transparency = 1 -- fully invisible
        bubble.Size = sizeVec
        bubble.Parent = hrp
        weldTo(bubble, hrp)
    else
        bubble.Size = sizeVec
    end
end

-- Visual Sphere (adornment preferred, fallback Part)
local function ensureRadiusSphere()
    if not showRadiusSphere or not hrp then return end

    local ok = pcall(function()
        local a = hrp:FindFirstChild("__HitSphereAdornment")
        if not a then
            a = Instance.new("SphereHandleAdornment")
            a.Name = "__HitSphereAdornment"
            a.Adornee = hrp
            a.AlwaysOnTop = false
            a.ZIndex = 1
            a.Parent = hrp
        end
        a.Radius = hitRadius
        a.Color3 = sphereColor
        a.Transparency = sphereTransparency
    end)
    if ok then return end

    local sp = workspace:FindFirstChild("__HitSpherePart")
    if not sp then
        sp = Instance.new("Part")
        sp.Name = "__HitSpherePart"
        sp.Shape = Enum.PartType.Ball
        sp.Anchored = true
        sp.CanCollide = false
        sp.Material = Enum.Material.ForceField
        sp.Parent = workspace
    end
    sp.Color = sphereColor
    sp.Transparency = sphereTransparency
    sp.Size = Vector3.new(hitRadius*2, hitRadius*2, hitRadius*2)
    sp.CFrame = hrp.CFrame
end

-- Keep fallback sphere aligned if used
RunService.Heartbeat:Connect(function()
    local sp = workspace:FindFirstChild("__HitSpherePart")
    if sp and hrp and showRadiusSphere then
        sp.CFrame = hrp.CFrame
        sp.Size = Vector3.new(hitRadius*2, hitRadius*2, hitRadius*2)
        sp.Color = sphereColor
        sp.Transparency = sphereTransparency
    end
end)

-- UI Controls
BlatantTab:CreateToggle({
    Name = "Auto Hit (Hitbox Expand, No Move)",
    CurrentValue = false,
    Flag = "HitboxExpandToggle",
    Callback = function(v)
        expandEnabled = v
        if v then
            ensureHitBubble()
            ensureRadiusSphere()
        end
    end,
})

BlatantTab:CreateSlider({
    Name = "Hit Radius (studs)",
    Range = {6, 60},
    Increment = 1,
    Suffix = "studs",
    CurrentValue = hitRadius,
    Flag = "HitboxExpandRadius",
    Callback = function(val)
        hitRadius = val
        ensureHitBubble()
        ensureRadiusSphere()
    end,
})

BlatantTab:CreateSlider({
    Name = "Click Cooldown (s)",
    Range = {0.05, 1.0},
    Increment = 0.05,
    Suffix = "s",
    CurrentValue = clickCooldown,
    Flag = "HitboxExpandCooldown",
    Callback = function(val) clickCooldown = val end,
})

BlatantTab:CreateToggle({
    Name = "Show 3D Radius Sphere",
    CurrentValue = showRadiusSphere,
    Flag = "ShowHitSphere",
    Callback = function(v)
        showRadiusSphere = v
        if not v then
            if hrp and hrp:FindFirstChild("__HitSphereAdornment") then
                hrp.__HitSphereAdornment:Destroy()
            end
            local sp = workspace:FindFirstChild("__HitSpherePart")
            if sp then sp:Destroy() end
        else
            ensureRadiusSphere()
        end
    end,
})

VisualTab:CreateColorPicker({
    Name = "Hit Sphere Color",
    Color = sphereColor,
    Flag = "HitSphereColor",
    Callback = function(c)
        sphereColor = c
        ensureRadiusSphere()
    end,
})

VisualTab:CreateSlider({
    Name = "Hit Sphere Transparency",
    Range = {0, 1},
    Increment = 0.05,
    Suffix = "",
    CurrentValue = sphereTransparency,
    Flag = "HitSphereTransparency",
    Callback = function(v)
        sphereTransparency = v
        ensureRadiusSphere()
    end,
})

-- Main Auto-Hit loop (no player movement)
local lastClick = 0
task.spawn(function()
    while true do
        RunService.Heartbeat:Wait()

        if showRadiusSphere then ensureRadiusSphere() end
        ensureHitBubble()

        if expandEnabled and hrp and hrp.Parent then
            local ball = findClientBall()
            if ball then
                local dist = (hrp.Position - ball.Position).Magnitude
                if dist <= hitRadius then
                    local now = tick()
                    if now - lastClick >= clickCooldown then
                        lastClick = now
                        local btn = getBumpButton()
                        if btn then pressBump(btn) end
                    end
                end
            end
        end
    end
end)

----------------------------------------------------------------
-- Info
----------------------------------------------------------------
InfoTab:CreateParagraph({
    Title = "UNPERFORMED | Volleyball Legends",
    Content = "Auto Hit (Hitbox Expand) presses Bump when the ball enters your expanded radius. 3D sphere visualizes the radius. Adjust radius, cooldown, color, and transparency."
})
